package com.potatomeme.effectivekotlin.docs

import java.util.*

// 아이템1. 가변성을 제한하라

// ----------------------------------------------------------------------------------------------------------------------------------------------

// 요소 중 일부는 상태(state)를 가질 수 있다. 읽고 쓸 수 있는 var 프로퍼티를 쓰거나 mutable 객체를 쓰면 상태를 가질 수 있다.
// 상태를 가지게 되면 여러 단점을 가지게 됩니다.

// 1. 프로그램을 이해하고 디버그하기 힘들어진다.
// 2. 가변성이 있으면, 코드의 실행을 추론하기 어렵다.
// 3. 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다.
// 4. 테스트하기 어렵다. 모든 상태를 테스트 해야 하므로, 변경이 많으면 많을 수록 더 많은 조합을 테스트 해야한다.
// 5. 상태 변경이 일어날 때 이러한 변경을 다른 부분에 알려야 하는 경우가 있다.

// 가변성은 이러한 단점들이 있지만 시스템의 상태를 나타내기 위한 중요한 방법이기도 합니다.
// 그렇기 때문에 가변성을 줄때는 잘생각해보고 사용해야 합니다.

// ----------------------------------------------------------------------------------------------------------------------------------------------

// 코틀린에서 가변성 제한하기

// 1. 읽기 전용 프로퍼티(val)

// val을 써서 읽기 전용 프로퍼티를 만들 수 있다. 값(value)처럼 동작하고 일반적인 방법으론 값이 변하지 않는다. 읽고 쓸 수 있는 프로퍼티는 var로 만든다.

fun item1Fun01(){
    val a = 10
    //a = 20 // 오류
}

// 읽기 전용 프로퍼티가 완전히 변경 불가능한 것은 아니다. mutable 객체를 담고 있다면, 내부적으로 변할 수 있다.
fun item1Fun02(){
    val list = mutableListOf(1, 2, 3)
    list.add(4)
    print(list)
}

// 읽기 전용 프로퍼티는 다른 프로퍼티를 활용하는 사용자 정의 게터로도 정의할 수 있다. var 프로퍼티를 사용하는 val 프로퍼티는 var 프로퍼티가 변할 때 변할 수 있다.
var step1: String = "A"
var step2: String = "B"
val result
    get()= "$step1 $step2"
fun item1Fun03(){
    println(result) // A B
    step2 = "C"
    println(result) // A C
}

// var은 게터와 세터를 모두 제공하지만, val은 변경이 불가능하므로 게터만 제공한다. 그래서 val을 var로 오버로드 할 수 있다.
interface item1Interface {
    var active: Boolean
}

class item1Class: item1Interface {
    override var active: Boolean = false
}

// val은 읽기 전용 프로퍼티지만 불변을 의미하진 않는다. 완전히 변경할 필요가 없으면 final 프로퍼티를 쓰는 게 좋다.

// ----------------------------------------------------------------------------------------------------------------------------------------------

// 2. 가변 컬렉션과 읽기 전용 컬렉션 구분하기
// 읽기 전용 : Iterable, Collection, Set, List 인터페이스
// 읽고 쓰기 가능 : MutableIterable, MutableCollection, MutableSet, MutableList 인터페이스
// Mutable이 붙은 인터페이스는 대응되는 읽기 전용 인터페이스를 상속받아서 변경을 위한 메서드를 추가한 것이다.
// 컬렉션 다운캐스팅은 읽기 전용으로 리턴하였는데, 이를 읽기전용으로만 사용하지 않는 계약을 위반하고, 추상화를 무시하는 행위이다. 이런 코드는 안전하지 않고, 예측하지 못한 결과를 초래한다.
// 읽기 전용에서 mutable로 바꿔야 한다면 복제(copy())를 통해서 새 mutable 컬렉션을 만드는 list.toMutableList()를 써야 한다.
fun item1Fun04() {
    val list = listOf(1, 2, 3)
    //list.add(4)   // 컴파일 에러 발생
    val mutableList = list.toMutableList()
    mutableList.add(4)
}

// ----------------------------------------------------------------------------------------------------------------------------------------------

// 3. 데이터 클래스의 copy
// String, Int처럼 내부적인 상태를 바꾸지 않는 불변(immutable) 객체사용의 장점

// 1. 한 번 정의된 상태가 유지되므로, 코드를 이해하기 쉽다.
// 2. immutable 객체는 공유했을 때도 충돌이 따로 이루어지지 않으므로, 병렬처리를 안전하게 할 수 있다.
// 3. immutable 객체에 대한 참조는 변경되지 않으므로, 쉽게 캐시할 수 있다.
// 4. immutable 객체는 방어적 복사본을 만들 필요가 없다.
// 5. immutable 객체는 다른 객체를 만들 때 활용하기 좋다.
// 6. immutable 객체는 ‘set’ 또는 ‘map의 키’로 사용할 수 있다. 참고로 mutable 객체는 이러한 것으로 사용할 수 없다. 해시 테이블은 처음 요소를 넣을 때 요소의 값을 기반으로 버킷을 결정하기 때문에, 변경이 일어나면 내부에서 요소를 찾을 수 없게 되어 버린다.

// mutable 객체 : 예측하기 어렵고 위험하다
// immutable 객체 : 변경할 수 없다 -> 자신의 일부를 수정한 새 객체를 만드는 메서드를 가져야 한다

// mutable 객체는 예측하기 어려우며 위험하다는 단점이 있다. 반면 immutable 객체는 변경할 수 없다는 단점이 있다. 따라서 immutable 객체는 자신의 일부를 수정한 새로운 객체를 만들어 내는 메서드를 가져야 한다.
fun item1Fun05() {
    data class User(
        val name: String,
        val surName: String
    ) {
        fun withSurname(surName: String) = User(name, surName)
    }

    var user = User("Maja", "Markiewicz")
    user = user.withSurname("Test")
    println(user)
    user = user.copy(name = "Test")
    println(user)
}

// ----------------------------------------------------------------------------------------------------------------------------------------------

// 다른 종류의 변경 가능 지점

// 변경 가능한 리스트를 만들어야 할 때 2가지 선택지가 있다
// mutable 컬렉션 만들기
// var로 읽고 쓸 수 있는 프로퍼티 만들기