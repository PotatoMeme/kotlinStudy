package com.potatomeme.modernandroid.docs


// 코투틴기초

// ---------------------------------------------------------------------------------------------------------------------------------------

// Async Task

// 손쉬운 비동기 프로그래밍
// 메모리 누수등 여러가지 문제
// api30 부터 Deprecated
// 대체재로 코루틴을 권장

// 루틴
// 메인 루틴, 메인(main)함수에서의 흐름
// 서브 루틴, 메인(main)함수내 개별함수에서의 흐름
// 코 루틴, 비동기 처리

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴  vs  스레드

// 코루틴은 스레드가 아님!!

// 프로그램을 실행 -> 메모리에 로드
// 여기서 로드된 인스턴스는 프로세스
// 이 프로세스 내에서 여러개의 독립된 실행의 흐름을 가지게 됩니다.
// 이 실행의 흐름의 단위가 스레드

// 프로세스가 메모리에서 영역을 할당
// 이 할당받은 공간을 Heap 메모리라 함함
// 각각의 스레드가 메모리에서 받는 영역들을 Stack 메모리라함

// 코투틴은 스레드라기 보다는 함수에 더비슷함

// 메모리 구조의 차이    코루틴 : 공유(Heap 메모리)  스레드 : 할당(Stack 메모리)

// 스레드 : 멀티코어를 사용하여 동일한 시간에 동시에 두가지 작업을 할수 있음 , 병행성
// 코루틴 : 동일한 시간에 같이 실행되지는 않음, 그렇지만 전환되는 속도가 빨라 동시에 처리되는것처럼 보임, 동시성 O 병행성 X

// 수행방식의 차이       코루틴 : 비선점형  스레드 : 선점형

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴의 장점
// Stack 메모리를 일일이 할당받지 않기때문에 메모리를 더 적게 차지합니다.
// Stack 메모리가 아닌 Heap 메모리이기때문에 context switching 을 하는데들어가는 오버헤가 줄어들게되서 더빠릅니다

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴의 사용
// suspend

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴 구조

// Coroutine Scope
// ex) CoroutineScope , GlobalScope(싱글톤 사용 추천안함)
// public interface CoroutineScope{
//      public val coroutineContext:CoroutineContext
// }

// Coroutine Context

// Dispatchers(Default,IO,Main,Unconfined) , Job&Deferred
// Dispatcher => 코루틴이 실행이되는 스레드의 타입을 지정
// Default , CPU 연산을 많이하는 작업에서 주로 사용
// IO , 파일 IO 나 네트워크 IO 를 주로사용할때 사용
// Main 은 UI 관련작업을 할때 사용

// Job & Deferred
// val job = scope.launch{
//      ....
// }// 취소나 흐름등을 제어할수 있음
// state , job의 상태를 확인 가능
// isActive , isCompleted , isCanceled
// method
// cancel,join,start

// Coroutine Builder
// launch, Job 객체 반환
// async, Deferred 객체 반환
// runBlocking, 사용동안 스레드 멈춤 사용x
// withContext, Dispatcher switch

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴 지연
// delay
// join
// await

// ---------------------------------------------------------------------------------------------------------------------------------------

// 코루틴 취소
// cancel
// cancelAndJoin
// withTimeout
// withTimeoutOrNull

// ---------------------------------------------------------------------------------------------------------------------------------------

// 예외 처리
// CoroutineExceptionHandler 를 이용하여 코루틴 내부의 기본 catch block 으로 사용할 수 있다.
// launch, actor : exception 발생 시 바로 예외가 발생
// async, produce : 중간에 exception 이 발생해도 await 를 만나야 발생
// Job.cancel()을 제외한 다른 exception 이 발생하면 부모의 코루틴까지 모두 취소시킴.
// 이는 structured concurrency 를 유지하기 위함으로 CoroutineExceptionHandler 를 설정해도 막을 수 없다.
// 여러개의 exception 이 발생하면 가장 먼저 발생한 exception 이 handler 로 전달되며 나머지는 무시된다.

// ---------------------------------------------------------------------------------------------------------------------------------------

// 정리
// CoroutineScope를 사용
// cpu 작업인가 IO작업인가? Default or IO
// 코루틴 처리후 값이 나와야 하는가? launch or async